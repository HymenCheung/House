### Object

##### toString

返回一个对象的全类名@对象的哈希码的十六进制数，这不满足不了我们要求的，需要对他进行重写(使用idea的快捷键)

```java
public class Animal {
    String name;
    int age;
    // 不用自己手动重写，使用idea的快捷键:alt + insert 选择toString
    public String toString() {
        return "Animal{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

##### hashCode

返回当前对象的内存地址经过hash运算后的到的整数值，可以等同看做是内存地址，需要重写(使用idea快捷键)

##### equals

时两个对象的比较规则，需要重写(使用idea的快捷键)

##### finalize

Objec中的析构方法，在对象被gc回收的时候，会执行，被启用

### String

字符串是引用类型，其实就是一个类，一个别人写好的class，一个类 里面有 属性、方法

https://www.runoob.com/manual/jdk11api/index.html

##### 字符串的内存结构

##### 构造方法

```java
String s = new String("张三");
String s1 = new String(new byte[]{1,2,3,4,5});
```

##### 常用方法

```java
public String(byte[] bytes)								//将数组转成字符串
public String(byte[] bytes,int offset,int length)	//将数组转成字符串，可指定读取位置

char charAt(int index)                                    // 返回指定索引的字符
	System.out.println("1234".charAt(2));					// 返回3
int compareTo(String anotherString)                        // 按照Unicode编码表对应的数字将一个个字符进行比较
    System.out.println("abcd".compareTo("abcc"));	//97 98 99 100 97 98 99 99
int compareToIgnoreCase(String str)                        // 按照Unicode编码表对应的数字将一个个字符进行比较，不区分大小写
    System.out.println("abcd".compareToIgnoreCase("abcD"));
String concat(String str)								//字符串的拼接
    System.out.println("abcd".concat("abc"));			//abcdabc
	
boolean contains(CharSequence s)                        // 判断此字符串是包含指定字符串
	System.out.println("abcd".contains("ab"));			//True
boolean endsWith(String suffix)                            // 判断此字符串是否以指定字符串结尾
    System.out.println("abcd".endsWith("cd"));			//判断当前字符是否以“cd”结尾
boolean startsWith(String prefix)                        // 判断此字符串是否以指定字符串开头
    System.out.println("abcd".startWith("ab"));			//True

boolean equals(Object anObject)                            // 比较两个字符串是否相等
    System.out.println("张三".equals("张三"));				//True
boolean equalsIgnoreCase(String anotherString)             // 比较两个字符串是否相等,不区分大小写
	System.out.println("张三A".equalsIgnoreCase("张三a"));	//true
byte[] getBytes()                                         // 将字符串的一个个字符转成byte类型的数字放到数组中返回
    byte[] bytes = "abc".getBytes();
    System.out.println(Arrays.toString(bytes));			//[97,98,99]

void getChars(int srcBegin,int srcEnd,char[] dst,int dstBegin)	//将此字符串中的字符复制到目标字符数组中
    char[] char1 = new char[5];
    "abcdef".getChars(0,3,char1,1);
    System.out.println(Arrays.toString(char1));				//[ , a, b, c,  ]
	
int indexOf(String str)                                     // 返回此字符在字符串中的索引，没有找到则返回-1
    System.out.println("abcd".indexOf("a"));	 		// 找到a第一次出现的索引 0
int lastIndexOf(String str)                               // 返回此字符在字符串中最后异常出现的索引，没有找到则返回-1
	System.out.println("abcabc".lastIndexOf("a"));	 		// 3
String repeat(int count)							//将一个字符串重复多少次
    System.out.println("abc".repeat(3));			//abcabcabc
int length()                                         // 返回此字符串的长度
	System.out.println("abc".length());				//	3
String replace(char oldChar, char newChar)                // 用新的字符串替换字符串中的旧字符串
    System.out.println("abc".replace('a','e'));				//	ebc
String replaceFirst(String regex, String replacement)     // 用新的字符串替换字符串中的旧字符串，只替换第一次
    System.out.println("abcabc".replaceFirst("a","e"));				//	ebcabc
String replaceAll(String regex, String replacement)         // 替换，全部替换
	System.out.println("abcabc".replaceAll("a","e"));				//	ebcebc
String[] split(String regex)                            // 以指定字符分割字符串，返回分割后的字符串数组
    String[] split = "张三_李四_王五".split("_");
    System.out.println(Arrays.toString(split));			//	[张三，李四，王五]
String[] split(String regex, int limit)                    // 以指定字符分割字符串，返回分割后的字符串数组，可以指定返回元素个数
	String[] split1 = "张三_李四_王五".split("_",2);
    System.out.println(Arrays.toString(split1));	//	[张三, 李四_王五]
    
String strip()											//删除字符串的前后空格
 	 System.out.println("   张三  ".strip());				//	张三
String stripLeading()									//删除字符串左边空格
     System.out.println("   张三  1".stripLeading());		//	张三  1
String stripTrailing()									//删除字符串右边空格
     System.out.println("1   张三  ".stripTrailing());		//	1   张三  
String substring(int beginIndex)                       // 截取子串（包含当前索引），指定从什么地方开始截取
     System.out.println("abcde".substring(1));			// bcde
String substring(int beginIndex, int endIndex)            // 截取子串，指定从什么地方开始截取，取多长（左闭右开）
	 System.out.println("abcde".substring(1,2));			// b
char[] toCharArray()									//将字符串中的一个个字符拆分开来，放到char数组中
     char[] chars2 = "123".toCharArray();
     System.out.println(Arrays.toString(chars2));		//[1, 2，3]
String toUpperCase()                                  // 将所有字符转大写
     System.out.println("abcde".toUpperCase());		 //ABCDE
String toLowerCase()                                  // 将所有字符转小写
	 System.out.println("ABCDE".toLowerCase());		 //abcde
static String valueOf(boolean b)                     //将boolean类型转成字符串
     String s = String.valueOf(false);
     System.out.println(s);							// false
static String valueOf(char[] data)                     //将数组类型转成字符串  
    char[] chars = {'a','b','c'}; 
    String s = String.valueOf(chars);
    System.out.println(s);							// abc
String trim()                                        // 去除字符串前后空白
	System.out.println("   张三  ".trim());			//	张三
boolean isEmpty()                                    // 判断字符串是否为空(长度是否为0)
	System.out.println("  ".isEmpty());				//false
    System.out.println("".isEmpty());				 //true
boolean isBlank()    								//判断字符串为""或者是一个" "
    System.out.println("  ".isBlank());				//true
	System.out.println("".isBlank());				//true
```

### StringBuffer

可以使用Stringbuffer来进行字符串拼接，避免内存浪费

字符串频繁拼接最好不要用String

```java
StringBuffer sb = new StringBuffer();
sb.append("张三");
sb.append("李四");
String s = sb.toString();            // 将拼接好的转成字符串
```

### StringBuilder

用法和StringBuffer一样，只不过是线程不安全的，但是效率较StringBuffer较高

### 包装类

包装类是对基本数据类型的包装，在基本数据类型的基础上加上了一些常用方法，并使其称为了引用数据类型

```java
// 如果没有包装类，传入一个基本数据类型，就会报错
public static void doSome(Object obj){}

// 传入的输一个int类型，但是如果传入一个null，就会报错，所以需要包装类
public static void doOther(int val){}
```

| 包装类       | 基本数据类型  |
| --------- | ------- |
| Byte      | byte    |
| Short     | short   |
| Integer   | int     |
| Long      | long    |
| Float     | float   |
| Double    | double  |
| Character | char    |
| Boolean   | boolean |

##### 常用方法

```java
static int parseInt(String s)                // 将字符串转成基本数据类型，注意只能是数字的字符串
boolean ture = Boolean.parseBoolean(true) ; 
static Integer valueOf(String s)            // 将字符串转成包装类型，注意只能是数字的字符串
    
static Integer valueOf(int i)                // 将基本数据类型转成包装类型
Integer integer = Integer.valueOf(123)
// 其他的包装类是一样使用的
```

##### 自动装箱和自动拆箱

基本类型贺包装类型之间可以自动转换，不需要手动调用相应方法

*自动装箱：就是将基本数据类型转成包装类型，自动发生*

*自动拆箱：将包装类型转成基本数据类型，自动发生*

##### 整形型常量池

为了提高效率，整数型常量池缓存了byte取值范围的255个数字，在创建包装类对象(数值型)的时候，如果在这个范围之内就不必创建对象直接使用

### Arrays

是javase提供的一个用于操作数组的一个工具类

```java
static <T> List<T> asList(T... a)        // 将数组转成列表
    
static String toString(数组)                // 将数组以字符串的形式进行返回
static int[] copyOf(int[] original, int newLength)            // 拷贝数组，指定拷贝几个元素
static int[] copyOfRange(int[] original, int from, int to)    // 拷贝数组，可以指定从什么索引开始，到什么索引结束
static void sort(int[] a)                            // 对数组进行排序    
static int binarySearch(int[] a, int key)            // 使用二分法在指定数组查找指定元素，返回查找到的元素所在的索引
```

### Enum

java5.0之后引入了枚举类，枚举类限制变量只能是预先设定好的值，正确使用枚举可以减少程序bug

定义

```java
enum Season{
    // 成员变量默认是public static final修饰的
    SPRING,
    SUMMER,
    AUTUMN,
    WINTER
}
```

**枚举类里面能有什么**

成员变量、构造器、普通方法、抽象方法

### BigDecima

浮点型存在问题

```java
double d1 = 1.0;
double d2 = 0.9;
double d3 = d1 - d2;        // 存在问题
```

创建

```java
BigDecimal b1 = new BigDecimal("1.0");
```

加减乘除

```java
BigDecimal b1 = new BigDecimal("1.0");            //这里是字符串，不用字符串，需要new MathContext()确定精确数字
BigDecimal b2 = new BigDecimal("0.9");
System.out.println(b1.add(b2 ,new MathContext(1)));            // 加法
System.out.println(b1.subtract(b2));    // 减法
System.out.println(b1.multiply(b2));    // 乘法
System.out.println(b1.divide(b2,2, RoundingMode.DOWN));        // 除法
```

### System

系统类，用于获取系统的属性和其他操作

```java
static native long currentTimeMillis()                // 获取到当前毫秒数
    System.currentTimeMillis()
static native void arraycopy(Object src,  int  srcPos,
                                        Object dest, int destPos,
                                        int length);            // 数组拷贝  源数组 从哪里开始拷 目标数组 从哪里拷进去 拷贝的元素个数

static void gc()                // 运行垃圾回收器
static void exit(int status)      // 终止java程序的运行
```

### 时间日期类

##### Date

构造方法

```java
Date date = new Date();
Date date = new Date(long date);            // 可以传入一个毫秒数
```

常用方法

```java
boolean after(Date when)        // 判断当前日期是否在此日期之后
boolean before(Date when)        // 判断当前日期是否在此日期之前 
```

##### SimpleDateFormat

用于格式化日期时间

**创建**

```java
// 构造方法可选参数
/*  y    年
    M    月
    d    日期
    H    小时
    m    分钟
    s    秒
    S    毫秒
*/

Date date1 = new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 24);
SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss SSS");    // 自定义时间日期格式
String format1 = sdf1.format(date1);
System.out.println(format1);
```

##### Calendar

是抽象类，无法直接创建对象，需要调用它的静态方法getInstance

```java
Calendar instance = Calendar.getInstance();        // 创建

System.out.println(instance.getTime().toLocaleString());        // 以我们看懂的形式输出

// 如何获取年、月、日等信息
System.out.println(instance.get(Calendar.YEAR));            // 获取年份信息
System.out.println(instance.get(Calendar.MONTH));           // 获取月份 老外习惯从0开始
System.out.println(instance.get(Calendar.DAY_OF_MONTH));    // 获取天数
System.out.println(instance.get(Calendar.HOUR_OF_DAY));     // 获取小时数
System.out.println(instance.get(Calendar.MINUTE));          // 获取分钟


System.out.println(instance.getActualMinimum(Calendar.DAY_OF_MONTH));            // 当前月份从几号开始
System.out.println(instance.getActualMaximum(Calendar.DAY_OF_MONTH));            // 当前月最多有几天


instance.set(Calendar.YEAR,2003);                          // 修改时间        根据传入的常量不同，修改的时机也不同

// 格式化
SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss SSS");
String format = sdf.format(instance.getTimeInMillis());
System.out.println(format);
```

##### LocalDate

新版的年、月、日类

```java
// 创建对象
LocalDate now = LocalDate.now();
System.out.println(now);
// 指定时间日期
LocalDate of = LocalDate.of(2008, 10, 9);
System.out.println(of);
// 获取年
int year = now.getYear();
System.out.println(year);
// 获取月份信息，getMonth获取的是英文月份
Month month = now.getMonth();
System.out.println(month);
// 获取月份信息(数组月份)
int monthValue = now.getMonthValue();
System.out.println(monthValue);
// 获取日
int dayOfMonth = now.getDayOfMonth();
System.out.println(dayOfMonth);
// 其他方法
System.out.println(now.getDayOfWeek());
System.out.println(now.getDayOfYear());
// 是否是闰年
System.out.println(of.isLeapYear());    
```

##### LocalTime

新版的时、分、秒类

```java
// 创建对象
LocalTime now = LocalTime.now();
System.out.println(now);
// 指定时间
LocalTime of = LocalTime.of(12, 30);
System.out.println(of);
// 获取时
int hour = now.getHour();
System.out.println(hour);
// 获取分钟
int minute = now.getMinute();
System.out.println(minute);
// 获取秒
int second = now.getSecond();
System.out.println(second);
```

##### LocalDateTime

新版的年、月、日、时、分、秒

```java
// 同时获取到年月日、时分秒信息
LocalDateTime now = LocalDateTime.now();
System.out.println(now);
// 指定时间
LocalDateTime of1 = LocalDateTime.of(2020, 10, 1, 10, 10);
System.out.println(now.getYear());      // 获取年
System.out.println(now.getMonthValue());      // 获取月
System.out.println(now.getDayOfMonth());      // 获取日
System.out.println(now.getHour());      // 获取时
System.out.println(now.getMinute());      // 获取分
System.out.println(now.getSecond());      // 获取秒
// 修改日期 使用withXXX方法
// 修该年
LocalDateTime localDateTime = now.withYear(2020);
// 修改月份
LocalDateTime localDateTime1 = now.withMonth(12);
// 修改日期
LocalDateTime localDateTime2 = now.withDayOfMonth(31);
System.out.println(localDateTime2);
// 增加年份使用plusXXX方法
LocalDateTime localDateTime3 = now.plusYears(2);
System.out.println(localDateTime3);
LocalDateTime localDateTime4 = now.plusDays(10);
System.out.println(localDateTime4);
// 对时间进行比较
LocalDateTime of = LocalDateTime.of(2021, 10, 9, 10, 27);
boolean after = now.isAfter(of);
System.out.println(after);
System.out.println(now.isBefore(of));
System.out.println(now.isEqual(of));
```

##### DateTimeFormatter

```java
// 不用看，格式化时间，默认格式 创建格式化对象，标准化时间
DateTimeFormatter df = DateTimeFormatter.ISO_DATE_TIME;
LocalDateTime now = LocalDateTime.now();
String format = df.format(now);
System.out.println(format);
// 自定义格式化时间
DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss SSS");
String format1 = dtf.format(now);
System.out.println(format1);
```

##### Instant

专用于操作秒级别的类

```java
// 创建对象
Instant now = Instant.now();
System.out.println(now);
// 增加时间
Instant instant = now.plusSeconds(20);  // 增加秒
System.out.println(instant);
Instant instant1 = now.plusNanos(1000);     // 增加纳秒
System.out.println(instant1);
// 获取秒
long epochSecond = now.getEpochSecond();
System.out.println(epochSecond);
// 获取纳秒
int nano = now.getNano();
System.out.println(nano);
```

### Math

```Java
math.abs()  //开方
math.pow(2，4)  //取幂
```

### Character

此外，此类还提供了大量静态方法 确定字符的类别（小写字母、数字等） 以及将字符从大写转换为小写和副 反之亦然。

统一码一致性

类的字段和方法是用术语定义的 来自 Unicode 标准的字符信息，特别是作为 Unicode 字符数据库一部分的 *UnicodeData* 文件。 此文件指定属性，包括每个 分配的 Unicode 代码点或字符范围。该文件可用 来自 [http://www.unicode.org](http://www.unicode.org/) 的 Unicode 联盟。`Character`

Unicode 字符表示形式

数据类型（以及对象封装的值）基于 原始 Unicode 规范，将字符定义为 固定宽度的 16 位实体。从那以后，Unicode 标准就成为了 更改为允许表示需要更多字符的字符 大于 16 位。法律*代码点*s 的范围现在是 U+0000 到 U+10FFFF，称为 *Unicode 标量值*。 （参考 Unicode 中 U+*n* 表示法[*的定义*](http://www.unicode.org/reports/tr27/#notation) 标准。`char``Character`

从 U+0000 到 U+FFFF 的字符集为 有时称为*基本多语言平面 （BMP）。*代码点较大的字符 比 U+FFFF 称为*增补字符*s。爪哇 平台在数组中使用 UTF-16 表示形式，并且 在和类中。在 这种表示，增补字符表示为一对 的值，第一个来自*高代理*项范围 （\uD800-\uDBFF），第二个来自*低代理项*范围 （\uDC00-\uDFFF）。`char``String``StringBuffer``char`

因此，值表示基本 多语言平面 （BMP） 代码点，包括代理项 代码点或 UTF-16 编码的代码单元。一个值表示所有 Unicode 码位， 包括补充代码点。较低（最不重要） 21 位用于表示 Unicode 代码 点和上限（最有效）11 位必须为零。 除非另有说明，否则有关的行为 增补字符和代理项值为 如下：`char``int``int``char`

- 仅接受值的方法不能支持 增补字符。他们处理来自 代理项范围作为未定义的字符。例如，返回 ，即使 此特定值（如果后跟字符串中的任何低代理项值） 将代表一封信。`char``char``Character.isLetter('\uD840')``false`
- 接受值的方法支持所有 Unicode 字符，包括增补字符。为 示例，返回，因为代码点值表示一个字母 （中日韩表意文字）。`int``Character.isLetter(0x2F81A)``true`



在 Java SE API 文档中，*Unicode 代码点*是 用于 U+0000 和 U+10FFFF 之间的字符值， *Unicode 代码*单元用于作为 *UTF-16* 编码的代码单元的 16 位值。有关 Unicode 术语的更多信息，请参阅 [Unicode 词汇表](http://www.unicode.org/glossary/)。`char`

这是一个[基于值的](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/doc-files/ValueBased.html)类;程序员应该将[相等](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Character.html#equals(java.lang.Object))的实例视为可互换的，而不应该 使用实例进行同步，否则可能会出现不可预测的行为 发生。例如，在将来的版本中，同步可能会失败。

```java
static int charCount(int codePoint) 	//确定所需的值数 表示指定的字符（Unicode 码位）。char
char charValue()						//返回此对象的值。Character
static int codePointAt(char[] a, int index)		//返回数组的给定索引处的代码点。char
static int	codePointAt(char[] a, int index, int limit)		//返回数组的给定索引处的代码点，其中只能使用小于的数组元素。charindexlimit
static int	codePointAt(CharSequence seq, int index)	//返回 的给定索引处的代码点。CharSequence
static int	codePointBefore(char[] a, int index)	//返回数组的给定索引前面的代码点。char
static int	codePointBefore(char[] a, int index, int start)
//返回数组的给定索引前面的代码点，其中只能使用大于或等于的数组元素。charindexstart
static int	codePointBefore(CharSequence seq, int index)
//返回 的给定索引前面的代码点。CharSequence
static int codePointCount(char[] a, int offset, int count)
//返回数组参数的子数组中的 Unicode 代码点数。char
static int	codePointCount(CharSequence seq, int beginIndex, int endIndex)
//返回文本范围 指定的字符序列。
static int	codePointOf(String name)	//返回由 指定的 Unicode 字符的代码点值 给定的字符名称。
static int	compare(char x, char y)		//以数字方式比较两个值。char
int	compareTo(Character anotherCharacter)	//以数字方式比较两个对象。Character
Optional<DynamicConstantDesc<Character>> describeConstable()
    //返回一个 Optional ，其中包含此 实例。
static int	digit(char ch, int radix)		//返回字符的数值 指定的基数。ch
static int	digit(int codePoint, int radix)		//返回指定字符 （Unicode ） 的数值 代码点）的指定基数。
boolean	equals(Object obj)					//将此对象与指定的对象进行比较。
static char	forDigit(int digit, int radix)		//确定 中特定数字的字符表示形式 指定的基数。
static byte	getDirectionality(char ch)		//返回给定的 Unicode 方向性属性 字符。
static byte	getDirectionality(int codePoint)	//返回给定的 Unicode 方向性属性 字符（Unicode 代码点）。
static String	getName(int codePoint)		//返回指定字符的名称，如果未分配代码点，则返回 null。codePoint	
static int	getNumericValue(char ch)	//返回指定的 Unicode 的值 字符代表。int
static int	getNumericValue(int codePoint)		//返回指定的值 字符（Unicode 码位）表示。int
static int	getType(char ch)			//返回一个值，该值指示字符的常规类别。
static int	getType(int codePoint)		//返回一个值，该值指示字符的常规类别。
int	hashCode()							//返回此的哈希代码;等于结果 的调用CharactercharValue()
static int	hashCode(char value)		//返回值的哈希代码;与 兼容。charCharacter.hashCode()
static char	highSurrogate(int codePoint)
   //返回表示指定增补字符 （Unicode） 的代理项对的前导代理项（高代理项代码单元） 码位）的 UTF-16 编码。
static boolean	isAlphabetic(int codePoint)	  //确定指定的字符（Unicode 代码点）是否为字母字符。
static boolean	isBmpCodePoint(int codePoint)
    //确定指定的字符（Unicode 码位） 位于基本多语言平面 （BMP） 中。
static boolean	isDefined(char ch)			 //确定字符是否在 Unicode 中定义。
static boolean	isDefined(int codePoint)	 //确定字符（Unicode 码位）是否在 Unicode 中定义。
static boolean	isDigit(char ch)			 //确定指定的字符是否为数字。
static boolean	isDigit(int codePoint)		 //确定指定的字符（Unicode 代码点）是否为数字。
static boolean	isHighSurrogate(char ch)	
    //确定给定值是否为 Unicode 高代理项代码单元（也称为前导代理项代码单元）。char
static boolean	isIdentifierIgnorable(char ch)
    //确定是否应将指定的字符视为 Java 标识符或 Unicode 标识符中可忽略的字符。
static boolean	isIdentifierIgnorable(int codePoint)
    //确定指定的字符（Unicode 码位）是否应视为 Java 标识符或 Unicode 标识符中可忽略的字符。
static boolean	isIdeographic(int codePoint)
 //确定指定的字符（Unicode 码位）是否为 CJKV （中文、日文、韩文和越南文）表意文字，定义如下 统一码标准。
static boolean	isISOControl(char ch)		//确定指定的字符是否为 ISO 控件 字符。
static boolean	isISOControl(int codePoint)
    //确定引用的字符（Unicode 代码点）是否为 ISO 控件 字符。
static boolean	isJavaIdentifierPart(char ch)
确定指定的字符是否可能是 Java 的一部分 标识符为第一个字符以外的标识符。
static boolean	isJavaIdentifierPart(int codePoint)
    //确定字符（Unicode 代码点）是否可能是 Java 的一部分 标识符为第一个字符以外的标识符。
static boolean	isJavaIdentifierStart(char ch)
    //确定指定的字符是否为 允许作为 Java 标识符中的第一个字符。
static boolean	isJavaIdentifierStart(int codePoint)
    //确定字符（Unicode 码位）是否为 允许作为 Java 标识符中的第一个字符。
static boolean	isJavaLetter(char ch)		//荒废的。替换为 isJavaIdentifierStart（char）。
static boolean	isJavaLetterOrDigit(char ch)	//荒废的。替换isJavaIdentifierPart（char）。
static boolean	isLetter(char ch)			//确定指定的字符是否为字母。
static boolean	isLetter(int codePoint)		//确定指定的字符（Unicode 代码点）是否为字母。
static boolean	isLetterOrDigit(char ch)	//确定指定的字符是字母还是数字。
static boolean	isLetterOrDigit(int codePoint)//确定指定的字符（Unicode 代码点）是字母还是数字。
static boolean	isLowerCase(char ch)		//确定指定的字符是否为小写字符。
static boolean	isLowerCase(int codePoint)	//确定指定的字符（Unicode 代码点）是否为 小写字符。
static boolean	isLowSurrogate(char ch)
    //确定给定值是否为 Unicode 低代理项代码单元（也称为尾随代理项代码单元）。char
static boolean	isMirrored(char ch)			//确定是否根据 统一码规范。
static boolean	isMirrored(int codePoint)
    //确定指定的字符（Unicode 码位） 根据 Unicode 规范进行镜像。
static boolean	isSpace(char ch)			//荒废的。替换为 isWhitespace（char）。
static boolean	isSpaceChar(char ch)		//确定指定的字符是否为 Unicode 空格字符。
static boolean	isSpaceChar(int codePoint)
    //确定指定的字符（Unicode 代码点）是否为 Unicode 空格字符。
static boolean	isSupplementaryCodePoint(int codePoint)
    //确定指定的字符（Unicode 码位） 在增补字符范围内。
static boolean	isSurrogate(char ch)		//确定给定值是否为 Unicode 代理项代码单元。char
static boolean	isSurrogatePair(char high, char low)
    //确定指定的值对是否为有效的 Unicode 代理项对。char
static boolean	isTitleCase(char ch)		//确定指定的字符是否为标题大小写字符。
static boolean	isTitleCase(int codePoint)
    //确定指定的字符（Unicode 代码点）是否为标题大小写字符。
static boolean	isUnicodeIdentifierPart(char ch)
    //确定指定的字符是否可能是 Unicode 的一部分 标识符为第一个字符以外的标识符。
static boolean	isUnicodeIdentifierPart(int codePoint)
    //确定指定的字符（Unicode 码位）是否可能是 Unicode 的一部分 标识符为第一个字符以外的标识符。
static boolean	isUnicodeIdentifierStart(char ch)
    //确定指定的字符是否允许作为 Unicode 标识符中的第一个字符。
static boolean	isUnicodeIdentifierStart(int codePoint)
    //确定指定的字符（Unicode 代码点）是否允许作为 Unicode 标识符中的第一个字符。
static boolean	isUpperCase(char ch)		//确定指定的字符是否为大写字符。
static boolean	isUpperCase(int codePoint)	//确定指定的字符（Unicode 代码点）是否为大写字符。
static boolean	isValidCodePoint(int codePoint)//确定指定的代码点是否为有效的 Unicode 代码点值。
static boolean	isWhitespace(char ch)		//根据 Java 确定指定的字符是否为空格。
static boolean	isWhitespace(int codePoint)
    //确定指定的字符（Unicode 码位）是否为 根据Java的空白。
static char	lowSurrogate(int codePoint)
   //返回表示指定补充字符 （Unicode） 的代理项对的尾随代理项（低代理项代码单元） 码位）的 UTF-16 编码。
static int	offsetByCodePoints(char[] a, int start, int count, int index, int codePointOffset)
    //返回给定子数组中的索引 这与给定的代码点偏移。charindexcodePointOffset
static int	offsetByCodePoints(CharSequence seq, int index, int codePointOffset)
    //返回给定字符序列中偏移量的索引 从给定的代码点。indexcodePointOffset
static char	reverseBytes(char ch)		//返回通过反转字节顺序获得的值 指定的值。char
static char[]	toChars(int codePoint)
    //将指定的字符（Unicode 代码点）转换为其 存储在数组中的 UTF-16 表示形式。char
static int	toChars(int codePoint, char[] dst, int dstIndex)
    //将指定的字符（Unicode 代码点）转换为其 UTF-16 表示形式。
static int	toCodePoint(char high, char low)	//将指定的代理项对转换为其补充代码 点值。
static char	toLowerCase(char ch)//使用大小写将字符参数转换为小写 来自 UnicodeData 文件的映射信息。
static int	toLowerCase(int codePoint)
    //将字符（Unicode 代码点）参数转换为 使用来自 UnicodeData 的大小写映射信息进行小写 文件。
String	toString()								//返回一个表示此值的对象。StringCharacter
static String	toString(char c)				//返回一个对象，该对象表示 指定。Stringchar
static String	toString(int codePoint)	
    //返回一个对象，该对象表示 指定字符（Unicode 代码点）。String
static char	toTitleCase(char ch)
    //使用大小写映射将字符参数转换为标题大小写 来自 UnicodeData 文件的信息。
static int	toTitleCase(int codePoint)
    //使用大小写映射将字符（Unicode 代码点）参数转换为标题大小写 来自 UnicodeData 文件的信息。
static char	toUpperCase(char ch)//使用大小写映射将字符参数转换为大写 来自 UnicodeData 文件的信息。
static int	toUpperCase(int codePoint)
    //将字符（Unicode 代码点）参数转换为 使用来自 UnicodeData 的大小写映射信息大写 文件。
static Character	valueOf(char c)				//返回表示指定值的实例。Characterchar
```

### Pattern

正则表达式的编译表示形式。

指定为字符串的正则表达式必须首先编译为 此类的实例。然后，可以使用生成的模式来创建 一个 [`Matcher`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Matcher.html) 对象，可以将任意字符序列与常规[字符序列](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/CharSequence.html)匹配 表达。执行匹配所涉及的所有状态都位于 匹配器，因此许多匹配器可以共享相同的模式。

因此，典型的调用序列是

> ```
>  Pattern p = Pattern.compile("a*b");
>  Matcher m = p.matcher("aaaaab");
>  boolean b = m.matches();
> ```



[`此类将 match`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#matches(java.lang.String,java.lang.CharSequence)) 方法定义为 当正则表达式仅使用一次时很方便。此方法 编译表达式并在单个表达式中将输入序列与其匹配 调用。声明

> ```
>  boolean b = Pattern.matches("a*b", "aaaaab");
> ```

等效于上面的三个语句，尽管对于重复匹配 效率较低，因为它不允许重用已编译的模式。



此类的实例是不可变的，可以安全地由多个实例使用 并发线程。[`Matcher`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Matcher.html) 类的实例对于 这种使用。

###### 正则表达式构造摘要

| 构建                                                         | 比赛                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 字符                                                         |                                                              |
| *x*                                                          | 字符 *x*                                                     |
| `\\`                                                         | 反斜杠字符                                                   |
| `\0`*n*                                                      | 八进制值为 n （0 *n* 7） 的字符`0``<=``<=`                   |
| `\0`*nn*                                                     | 八进制值为 *nn* （0 *n* 7） 的字符`0``<=``<=`                |
| `\0`*lnO*                                                    | 八进制值为 *mnn* （0 *m* 3， 0 *n* 7）`0``<=``<=``<=``<=`    |
| `\x`*呵呵*                                                   | 十六进制值为 *hh* 的字符`0x`                                 |
| `\u`*呵*                                                     | 十六进制值为 *hhhh 的*字符`0x`                               |
| `\x`*{h...h}*                                                | 十六进制值为 *h...* h （[`Character.MIN_CODE_POINT`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Character.html#MIN_CODE_POINT) <= *h...h* <= [`字符.MAX_代码_点`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Character.html#MAX_CODE_POINT)`0x``0x`) |
| `\N{`*名字*`}`                                               | 具有 Unicode 字符名称*“name”*的字符                          |
| `\t`                                                         | 制表符 （`'\u0009'`)                                         |
| `\n`                                                         | 换行符（换行）字符 （`'\u000A'`)                             |
| `\r`                                                         | 回车符 （`'\u000D'`)                                         |
| `\f`                                                         | 表单馈送字符 （`'\u000C'`)                                   |
| `\a`                                                         | 警报（铃铛）字符 （`'\u0007'`)                               |
| `\e`                                                         | 转义字符 （`'\u001B'`)                                       |
| `\c`*x*                                                      | 对应于 *x* 的控制字符                                        |
| 字符类                                                       |                                                              |
| `[abc]`                                                      | `a`、 或（简单类）`b``c`                                     |
| `[^abc]`                                                     | 除 、 或 （否定） 之外的任何字符`a``b``c`                    |
| `[a-zA-Z]`                                                   | `a`通过 或 通过 ，包含（范围）`z``A``Z`                      |
| `[a-d[m-p]]`                                                 | `a`通过 或通过 ： （工会）`d``m``p``[a-dm-p]`                |
| `[a-z&&[def]]`                                               | `d`、 或（交集）`e``f`                                       |
| `[a-z&&[^bc]]`                                               | `a`通过 除了和：（减法）`z``b``c``[ad-z]`                    |
| `[a-z&&[^m-p]]`                                              | `a`通过 而不是通过：（减法）`z``m``p``[a-lq-z]`              |
| 预定义的字符类                                               |                                                              |
| `.`                                                          | 任何字符（可能匹配也可能不匹配[行终止符](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#lt)）) |
| `\d`                                                         | 数字：如果未设置 [* UNICODE_CHARACTER_CLASS](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#UNICODE_CHARACTER_CLASS)。请参阅 [Unicode 支持](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#unicodesupport)。`[0-9]` |
| `\D`                                                         | 非数字：`[^0-9]`                                             |
| `\h`                                                         | 水平空格字符：`[ \t\xA0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000]` |
| `\H`                                                         | 非水平空格字符：`[^\h]`                                      |
| `\s`                                                         | 空格字符：如果未设置[UNICODE_CHARACTER_CLASS](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#UNICODE_CHARACTER_CLASS)。请参阅 [Unicode 支持](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#unicodesupport)。`[ \t\n\x0B\f\r]` |
| `\S`                                                         | 非空格字符：`[^\s]`                                          |
| `\v`                                                         | 垂直空格字符：`[\n\x0B\f\r\x85\u2028\u2029]`                 |
| `\V`                                                         | 非垂直空格字符：`[^\v]`                                      |
| `\w`                                                         | 单词字符：如果未设置[UNICODE_CHARACTER_CLASS](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#UNICODE_CHARACTER_CLASS)。请参阅 [Unicode 支持](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#unicodesupport)。`[a-zA-Z_0-9]` |
| `\W`                                                         | 非单词字符：`[^\w]`                                          |
| **POSIX 字符类（仅限 US-ASCII）**                            |                                                              |
| `\p{Lower}`                                                  | 小写字母字符：`[a-z]`                                        |
| `\p{Upper}`                                                  | 大写字母字符：`[A-Z]`                                        |
| `\p{ASCII}`                                                  | 所有 ASCII：`[\x00-\x7F]`                                    |
| `\p{Alpha}`                                                  | 字母字符：`[\p{Lower}\p{Upper}]`                             |
| `\p{Digit}`                                                  | 十进制数字：`[0-9]`                                          |
| `\p{Alnum}`                                                  | 字母数字字符：`[\p{Alpha}\p{Digit}]`                         |
| `\p{Punct}`                                                  | 标点符号：其中之一`!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~`         |
| `\p{Graph}`                                                  | 可见字符：`[\p{Alnum}\p{Punct}]`                             |
| `\p{Print}`                                                  | 可打印字符：`[\p{Graph}\x20]`                                |
| `\p{Blank}`                                                  | 空格或制表符：`[ \t]`                                        |
| `\p{Cntrl}`                                                  | 控制字符：`[\x00-\x1F\x7F]`                                  |
| `\p{XDigit}`                                                 | 十六进制数字：`[0-9a-fA-F]`                                  |
| `\p{Space}`                                                  | 空格字符：`[ \t\n\x0B\f\r]`                                  |
| java.lang.Character 类（简单的 [java 字符类型](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#jcc)) |                                                              |
| `\p{javaLowerCase}`                                          | 相当于 java.lang.Character.isLowerCase（）                   |
| `\p{javaUpperCase}`                                          | 相当于 java.lang.Character.isUpperCase（）                   |
| `\p{javaWhitespace}`                                         | 相当于 java.lang.Character.isWhitespace（）                  |
| `\p{javaMirrored}`                                           | 相当于 java.lang.Character.isMirrored（）                    |
| Unicode 脚本、块、类别和二进制属性的类                       |                                                              |
| `\p{IsLatin}`                                                | 拉丁字母字符（[脚本](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#usc)) |
| `\p{InGreek}`                                                | 希腊块中的字符（[块](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#ubc)) |
| `\p{Lu}`                                                     | 大写字母（[类别](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#ucc)) |
| `\p{IsAlphabetic}`                                           | 字母字符（[二进制属性](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#ubpc)) |
| `\p{Sc}`                                                     | 货币符号                                                     |
| `\P{InGreek}`                                                | 除希腊语块（否定）之外的任何字符                             |
| `[\p{L}&&[^\p{Lu}]]`                                         | 除大写字母（减法）以外的任何字母                             |
| 边界匹配器                                                   |                                                              |
| `^`                                                          | 一行的开头                                                   |
| `$`                                                          | 行尾                                                         |
| `\b`                                                         | 字边界：（位置 其中非单词字符与单词字符相邻）`(?:(?<=\w)(?=\W)|(?<=\W)(?=\w))` |
| `\b{g}`                                                      | Unicode 扩展字形簇边界                                       |
| `\B`                                                         | 非字边界：`[^\b]`                                            |
| `\A`                                                         | 输入的开头                                                   |
| `\G`                                                         | 上一场比赛结束                                               |
| `\Z`                                                         | 输入的末尾，但对于最终[终止符](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#lt)（如果有） |
| `\z`                                                         | 输入的结尾                                                   |
| 换行匹配器                                                   |                                                              |
| `\R`                                                         | 任何 Unicode 换行序列，都等效于`\u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]` |
| Unicode 扩展字素匹配器                                       |                                                              |
| `\X`                                                         | 任何 Unicode 扩展字素簇                                      |
| 贪婪的量词                                                   |                                                              |
| *X*`?`                                                       | *X*，一次或根本不                                            |
| *X*`*`                                                       | *X*，零次或更多次                                            |
| *X*`+`                                                       | *X*，一次或多次                                              |
| *X**n*`{``}`                                                 | *X*，正好 *n* 次                                             |
| *X**n*`{``,`}                                                | *X*，至少 *n* 次                                             |
| *X**n**m*`{``,``}`                                           | *X*，至少 *n* 次但不超过 *m* 次                              |
| 不情愿的量词                                                 |                                                              |
| *X*`??`                                                      | *X*，一次或根本不                                            |
| *X*`*?`                                                      | *X*，零次或更多次                                            |
| *X*`+?`                                                      | *X*，一次或多次                                              |
| *X**n*`{``}?`                                                | *X*，正好 *n* 次                                             |
| *X**n*`{``,}?`                                               | *X*，至少 *n* 次                                             |
| *X**n**m*`{``,``}?`                                          | *X*，至少 *n* 次但不超过 *m* 次                              |
| 所有格量词                                                   |                                                              |
| *X*`?+`                                                      | *X*，一次或根本不                                            |
| *X*`*+`                                                      | *X*，零次或更多次                                            |
| *X*`++`                                                      | *X*，一次或多次                                              |
| *X**n*`{``}+`                                                | *X*，正好 *n* 次                                             |
| *X**n*`{``,}+`                                               | *X*，至少 *n* 次                                             |
| *X**n**m*`{``,``}+`                                          | *X*，至少 *n* 次但不超过 *m* 次                              |
| 逻辑运算符                                                   |                                                              |
| *扎伊*                                                       | *X* 后跟 *Y*                                                 |
| *X**Y*`|`                                                    | *X* 或 *Y*                                                   |
| `(`*X*`)`                                                    | X，作为[捕获组](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#cg) |
| 返回引用                                                     |                                                              |
| `\`*n*                                                       | 无论第 *n*个[捕获组](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#cg)匹配什么 |
| `\`*K**<名称*>                                               | 无论[命名捕获组](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#groupname)“名称”匹配什么 |
| 报价单                                                       |                                                              |
| `\`                                                          | 什么都没有，但引用了以下字符                                 |
| `\Q`                                                         | 什么都没有，但引用所有字符，直到`\E`                         |
| `\E`                                                         | 什么都没有，但结束引用开始于`\Q`                             |
| 特殊构造（命名捕获和非捕获）                                 |                                                              |
| `(?`*X*`)`                                                   | *X*，作为命名捕获组                                          |
| `(?:`*X*`)`                                                  | *X*，作为非捕获组                                            |
| `(?idmsuxU-idmsuxU) `                                        | 什么都没有，但打开 - 关闭比赛标志 i [d](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#UNIX_LINES) [m](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#MULTILINE) [s](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#DOTALL) [u](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#UNICODE_CASE) [x](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#COMMENTS) [U](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#UNICODE_CHARACTER_CLASS) |
| `(?idmsuxU-idmsuxU:`*X*`)`                                   | *X*，作为[非捕获组](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#cg)，具有 给定的标志 [I](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#CASE_INSENSITIVE) [d](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#UNIX_LINES) [m](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#MULTILINE) [s](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#DOTALL) [u](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#UNICODE_CASE) [x](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#COMMENTS) [U](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#UNICODE_CHARACTER_CLASS) 开 - 关 |
| `(?=`*X*`)`                                                  | *X*，通过零宽度正前瞻                                        |
| `(?!`*X*`)`                                                  | *X*，通过零宽度负前瞻                                        |
| `(?<=`*X*`)`                                                 | *X*，通过零宽度正后视                                        |
| `(?*X*`)`                                                    | *X*，通过零宽度负后视                                        |
| `(?>`*X*`)`                                                  | *X*，作为一个独立的、非捕获的群体                            |

------

###### 反斜杠、转义和引号

反斜杠字符 （） 用于引入转义 上表中定义的构造，以及引用字符 否则将被解释为未转义的构造。因此， 表达式匹配单个反斜杠并匹配 左大括号。`'\'``\\``\{`

在任何字母字符之前使用反斜杠是错误的 不表示转义的构造;这些是为将来保留的 正则表达式语言的扩展。可以使用反斜杠 在非字母字符之前，无论该字符是否 未转义结构的一部分。

解释 Java 源代码中字符串文本中的反斜杠 根据 Java 语言规范的要求，作为 Unicode 转义（第 3.3 节）或其他字符转义（[第 3.10.6](https://docs.oracle.com/javase/specs/jls/se20/html/jls-3.html#jls-3.10.6) 节）。 因此，有必要在字符串中使用双反斜杠 表示正则表达式的文字，以保护它们免受 由 Java 字节码编译器解释。字符串文本 ，例如，在以下情况下匹配单个退格符 解释为正则表达式，同时匹配 字边界。字符串文本是非法的 并导致编译时错误;为了匹配字符串，必须使用字符串文本。`"\b"``"\\b"``"\(hello\)"``(hello)``"\\(hello\\)"`

###### 字符类

字符类可能出现在其他字符类中，并且 可以由联合运算符（隐式）和交集组成 运算符 （）。 联合运算符表示一个类，其中包含每个字符 在其至少一个操作数类中。交集运算符 表示一个类，该类包含其两个字符中的每个字符 操作数类。`&&`

字符类运算符的优先级如下，从 从高到低：

| 优先 | 名字     | 例               |
| ---- | -------- | ---------------- |
| 1    | 字面转义 | `\x`             |
| 2    | 分组     | `[...]`          |
| 3    | 范围     | `a-z`            |
| 4    | 联盟     | `[a-e][i-u]`     |
| 5    | 路口     | `[a-z&&[aeiou]]` |



请注意，内部有一组不同的元字符有效 字符类比字符类外部的字符类。例如， 正则表达式在 字符类，而表达式变为范围 形成元特征。`.``-`

###### 行终止符

*行终止符*是一个或两个字符的序列，用于标记 输入字符序列的一行的末尾。以下是 被识别为行终止符：

- 换行符 （），`'\n'`
- 紧跟换行符的回车符 字符 （），`"\r\n"`
- 独立的回车符 （），`'\r'`
- 下一行字符 （），`'\u0085'`
- 行分隔符 （） 或`'\u2028'`
- 段落分隔符 （）。`'\u2029'`



如果激活[`UNIX_LINES`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#UNIX_LINES)模式，则唯一的线路终止符 识别的是换行符。

正则表达式匹配除行之外的任何字符 终止符，除非指定了 [`DOTALL`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#DOTALL) 标志。`.`

如果未激活 [`MULTILINE`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#MULTILINE) 模式，则正则表达式将忽略行终止符，并且仅在 整个输入序列。正则表达式在 整个输入序列的末尾，但也在最后一行之前匹配 终止符（如果后面没有任何其他输入字符）。其他生产线 终止符将被忽略，包括最后一个终止符（如果后面跟着其他终止符） 输入字符。`^``$`

如果激活[`了多行`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#MULTILINE)模式，则在输入开始时和任何线路终结符之后匹配 输入末尾除外。在多行模式下，匹配刚好在[`行`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#MULTILINE)终止符之前或输入序列的末尾。`^``$`

###### 分组和捕获

###### 组号

捕获组通过计算其左括号来编号 从左到右。在表达式中，例如，有 是四个这样的组：`((A)(B(C)))`

1. `((A)(B(C)))`
2. `(A)`
3. `(B(C))`
4. `(C)`

组 0 始终代表整个表达式。

捕获组之所以如此命名，是因为在匹配期间，每个子序列 保存与此类组匹配的输入序列。被俘虏的 子序列可以在表达式的后面通过反向引用在表达式中使用，并且 匹配操作完成后，也可以从匹配器检索。

###### 组名称

还可以为捕获组分配一个“名称”， 然后通过“名称”反向引用。组名称由 以下字符。第一个字符必须是 .`named-capturing group``letter`

- 大写字母通过 （ 到 ），`'A'``'Z'``'\u0041'``'\u005a'`
- 小写字母通过（到），`'a'``'z'``'\u0061'``'\u007a'`
- 数字通过 （ 到 ），`'0'``'9'``'\u0030'``'\u0039'`



A 仍按组编号中所述进行[编号](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#gnumber)。`named-capturing group`

与组关联的捕获输入始终是子序列 该组最近匹配的。如果对组进行第二次评估 由于量化，那么它先前捕获的值（如果有的话）将 如果第二次评估失败，则保留。将字符串与表达式匹配，例如，叶子 第二组设置为 。所有捕获的输入都将在 每场比赛的开始。`"aba"``(a(b)?)+``"b"`

以 开头的组要么是纯组，要么是非*捕获*组 不捕获文本，不计入组总数或*命名捕获*组。`(?`

###### 统一码支持

此类符合 [*Unicode 技术级别 1 标准#18：Unicode正则表达式*](http://www.unicode.org/reports/tr18/)，以及RL2.1 规范等价物和 RL2.2 扩展字素簇。

**Unicode 转义序列**，例如在 Java 源代码中 按照 Java 语言规范第 [3.3](https://docs.oracle.com/javase/specs/jls/se20/html/jls-3.html#jls-3.3) 节中所述进行处理。 这样的转义序列也直接由正则表达式实现 解析器，以便可以在从中读取的表达式中使用 Unicode 转义 文件或从键盘。因此，字符串和 虽然不相等，但编译成相同的模式，其中 将字符与十六进制值匹配。`\u2014``"\u2014"``"\\u2014"``0x2014`

Unicode 字符也可以直接使用其十六进制表示**法（十六进**制码位值）表示，如构造中所述，例如补充字符 U+2011F 可以是 指定为 ，而不是两个连续的 Unicode 转义 代理对的序列 .`\x{...}``\x{2011F}``\uD840``\uDD1F`

**Unicode 字符名称**受命名字符结构支持...，例如，指定字符 。支持的字符名称 此类是与 [`Character.codePointOf（name）`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Character.html#codePointOf(java.lang.String)) 匹配的有效 Unicode 字符名称。`\N{``}``\N{WHITE SMILING FACE}``\u263A`

[**Unicode 扩展字素簇受字**](http://www.unicode.org/reports/tr18/#Default_Grapheme_Clusters)素支持 聚类匹配器和相应的边界匹配器。`\X``\b{g}`

Unicode 脚本、块、类别和二进制属性是用 和构造，如在Perl中。*道具*匹配，如果 输入具有属性 prop，而*如果*输入具有该属性，则 *prop* 不匹配。`\p``\P``\p{``}``\P{``}`

脚本、块、类别和二进制属性都可以在内部使用 和字符类之外。

**脚本**使用前缀 指定，如 中所示，或使用关键字（或其短关键字 形式 ） 如 或 。`Is``IsHiragana``script``sc``script=Hiragana``sc=Hiragana`

支持的脚本名称是有效的脚本名称 由 [`UnicodeScript.forName`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Character.UnicodeScript.html#forName(java.lang.String)) 接受和定义。`Pattern`

**块**使用前缀 指定，如 ，或使用关键字（或其短 形式 ） 如 或 。`In``InMongolian``block``blk``block=Mongolian``blk=Mongolian`

支持的块名称是有效的块名称 由 [`UnicodeBlock.forName`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Character.UnicodeBlock.html#forName(java.lang.String)) 接受和定义。`Pattern`

可以使用可选前缀指定**类别**： 两者和表示 Unicode 的类别 函件。与脚本和块相同，也可以指定类别 通过使用关键字（或其缩写形式）如 或 。`Is``\p{L}``\p{IsL}``general_category``gc``general_category=Lu``gc=Lu`

支持的类别是[`字符`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Character.html)类指定的版本中[*的 Unicode 标准的*](http://www.unicode.org/standard/standard.html)类别。类别名称是那些 在标准中定义，既规范又信息。

**二进制属性**使用前缀指定，如 中所示。支持的二进制属性是`Is``IsAlphabetic``Pattern`

- 字母
- 表意文字
- 信
- 小写
- 大写
- 标题案例
- 标点
- 控制
- White_Space
- 数字
- Hex_Digit
- Join_Control
- Noncharacter_Code_Point
- 分配



以下**预定义字符类**和 **POSIX 字符类**符合附录 C 的建议：Unicode 技术标准 #18 的*兼容性属性*[*： Unicode 正则表达式*](http://www.unicode.org/reports/tr18/)（指定[`UNICODE_CHARACTER_CLASS`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#UNICODE_CHARACTER_CLASS)标志时）。

| 类           | 比赛                                                         |
| ------------ | ------------------------------------------------------------ |
| `\p{Lower}`  | 小写字符：`\p{IsLowercase}`                                  |
| `\p{Upper}`  | 大写字符：`\p{IsUppercase}`                                  |
| `\p{ASCII}`  | 所有 ASCII：`[\x00-\x7F]`                                    |
| `\p{Alpha}`  | 字母字符：`\p{IsAlphabetic}`                                 |
| `\p{Digit}`  | 十进制数字字符：`\p{IsDigit}`                                |
| `\p{Alnum}`  | 字母数字字符：`[\p{IsAlphabetic}\p{IsDigit}]`                |
| `\p{Punct}`  | 标点字符：`\p{IsPunctuation}`                                |
| `\p{Graph}`  | 可见字符：`[^\p{IsWhite_Space}\p{gc=Cc}\p{gc=Cs}\p{gc=Cn}]`  |
| `\p{Print}`  | 可打印字符：`[\p{Graph}\p{Blank}&&[^\p{Cntrl}]]`             |
| `\p{Blank}`  | 空格或制表符：`[\p{IsWhite_Space}&&[^\p{gc=Zl}\p{gc=Zp}\x0a\x0b\x0c\x0d\x85]]` |
| `\p{Cntrl}`  | 控制字符：`\p{gc=Cc}`                                        |
| `\p{XDigit}` | 十六进制数字：`[\p{gc=Nd}\p{IsHex_Digit}]`                   |
| `\p{Space}`  | 空格字符：`\p{IsWhite_Space}`                                |
| `\d`         | 一个数字：`\p{IsDigit}`                                      |
| `\D`         | 非数字：`[^\d]`                                              |
| `\s`         | 空格字符：`\p{IsWhite_Space}`                                |
| `\S`         | 非空格字符：`[^\s]`                                          |
| `\w`         | 一个单词字符：`[\p{Alpha}\p{gc=Mn}\p{gc=Me}\p{gc=Mc}\p{Digit}\p{gc=Pc}\p{IsJoin_Control}]` |
| `\W`         | 非单词字符：`[^\w]`                                          |



行为类似于 java.lang.Character 的类别 布尔值是方法*名方法*（已弃用的方法除外）是 可通过相同的 `\p{`*prop*`}` 语法使用，其中 指定的属性具有名称 `Java*方法名称*`。

###### 与 Perl 5 的比较

该引擎执行传统的基于 NFA 的匹配 与 Perl 5 中发生的有序交替一样。`Pattern`

此类不支持的 Perl 构造：

- 反向引用构造，*n* 表示 *第 n*个捕获组和[命名捕获组](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#groupname)*的名称*。`\g{``}``\g{``}`
- 条件构造*条件* X 和*条件**X**Y*，`(?(``)``)``(?(``)``|``)`
- 嵌入式代码构造代码和*代码*，`(?{``})``(??{``})`
- 嵌入的注释语法 ，以及`(?#comment)`
- 预处理操作 、 和 。`\l``\u``\L``\U`

此类支持但 Perl 不支持的构造：

- [如上所述](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#cc)的字符类并集和交集。

与 Perl 的显著区别：

- 在 Perl 中，通过总是被解释 作为回参考;大于 is 的反斜杠转义数字 如果至少存在那么多子表达式，则被视为反向引用， 否则，如果可能的话，它被解释为八进制转义。在此 类八进制转义必须始终以零开头。在此类中，通过总是被解释为返回 引用，如果 至少在正则中存在该点的许多子表达式 表达式，否则解析器将删除数字，直到数字 小于或等于现有组数或为一位数。`\1``\9``9``\1``\9`
- Perl 使用该标志来请求恢复的匹配 最后一场比赛结束的地方。此功能是隐式提供的 通过 [`Matcher`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Matcher.html) 类：[`重复调用 find`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Matcher.html#find()) 方法将从最后一个匹配项中断的地方恢复， 除非重置匹配器。`g`
- 在 Perl 中，表达式顶层的嵌入式标志会影响 整个表达式。在此类中，嵌入式标志始终生效 在它们出现的点，无论它们处于顶层还是 在小组内;在后一种情况下，标志在 组就像在 Perl 中一样。
- Perl 中的*自由间距模式*（称为*注释）* 此类中的模式）在常规中表示 表达式（或在编译时通过 [`COMMENTS`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/regex/Pattern.html#COMMENTS) 标志 表达式）不会忽略字符类中的空格。在 这个类，字符类内部的空格必须转义为 在注释模式下被视为正则表达式的一部分。`(?x)`

更精确地描述正则表达式的行为 构造，请参阅[*掌握正则表达式，第 3 版*，Jeffrey E. F. Friedl， O'Reilly and Associates， 2006.](http://www.oreilly.com/catalog/regex3/)

```java
Predicate<String>  asMatchPredicate()   //创建一个谓词，用于测试此模式是否与给定的输入字符串匹配。
    
Predicate<String> asPredicate()     	//创建一个谓词，用于测试是否在给定输入中找到此模式 字符串。
    
static Pattern compile(String regex)	//将给定的正则表达式编译为模式。
    String regex = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
    Pattern pattern = Pattern.compile(regex);
Matcher matcher(CharSequence input)		//创建一个匹配器，该匹配器将给定的输入与此模式匹配。
    Matcher matcher = pattern.matcher(email);
static boolean matches(String regex, CharSequence input)	//编译给定的正则表达式并尝试匹配给定的 输入反对它。
    
static Pattern compile(String regex, int flags)		//将给定的正则表达式编译为具有给定标志。
    
int flags()								//返回此模式的匹配标志。
    

Map<String,Integer> namedGroups()		//返回从捕获组名称到组号的不可修改映射。
    
String pattern()						//返回从中编译此模式的正则表达式。
    
static String quote(String s)			//返回指定 .StringString
    
String[] split(CharSequence input)		//围绕此模式的匹配项拆分给定的输入序列。
    
String[] split(CharSequence input, int limit)		//围绕此模式的匹配项拆分给定的输入序列。
    
Stream<String>	splitAsStream(CharSequence input)	//从给定的输入序列围绕此匹配项创建流 模式。
    
String	toString()						//返回此模式的字符串表示形式。
    
```

